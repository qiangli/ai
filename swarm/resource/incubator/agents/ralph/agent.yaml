#!/usr/bin/env ai /agent:ralph/ralph --script

# Ralph orchestrator (inspired by upstream Ralph-for-Claude-Code) implemented in *pure YAML agents*.
#
# Notes:
# - Upstream runs an external AI CLI; in this agent pack, the "execution" step is implemented by
#   calling a configurable `worker` agent once per iteration.
# - State is stored in files in the current working directory, matching the upstream spirit.
# - Template files are EMBEDDED here (PROMPT/AGENT/fix_plan/specs/.gitkeep) and can be materialized
#   into a project directory via small Go tools in this YAML.
#
# Implements core features from upstream Ralph-for-Claude-Code (see comments for source attribution):
# - rate limiting with hourly reset
# - session continuity + expiry + reset triggers
# - circuit breaker (CLOSED/HALF_OPEN/OPEN)
# - dual-condition exit gate: completion_indicators AND explicit EXIT_SIGNAL:true
# - status extraction + fallback heuristics
# - PRD import/setup using templates
# - monitoring dashboard (single-shot, non-tmux)
#
---
pack: "ralph"
log_level: "info"

# =============================================================================
# Agents
# =============================================================================
agents:
  - name: "help"
    display: "ðŸ’¡ Ralph Help"
    description: |
      Ralph employs Geoffrey Huntley's technique for continuous autonomous development cycles, named after [Ralph Wiggum](https://ghuntley.com/ralph/).
      This system empowers agents to iteratively refine and enhance projects autonomously until completion, incorporating safeguards against infinite loops and excessive API consumption.
    model: default/any
    instruction: |
      As the Ralph Help Agent, your role is to assist users in utilizing Ralph effectively.
      Ralph, inspired by Geoffrey Huntley's methodology, automates continuous, iterative project improvements through autonomous agents, with precautions to avoid infinite loops and API misuse.

      Available Ralph Agents and Tools:

      ## Agents
      - "agent:ralph/ralph"
      - "agent:ralph/setup"
      - "agent:ralph/import"
      - "agent:ralph/loop"
      - "agent:ralph/once"
      - "agent:ralph/worker"
      - "agent:ralph/monitor"
      - "agent:ralph/analyzer"

      Execute `ai:read_agent_config` to acquire detailed information necessary for addressing user inquiries.

      ## Tools
      - "ralph:write_template_prompt"
      - "ralph:write_template_agent"
      - "ralph:write_template_fix_plan"
      - "ralph:write_template_specs_gitkeep"

      Use `ai:read_tool_config` to gather detailed information needed to respond to user questions.
    functions:
      - "ai:*"
      - "agent:ralph/ralph"
      - "agent:ralph/setup"
      - "agent:ralph/import"
      - "agent:ralph/loop"
      - "agent:ralph/once"
      - "agent:ralph/worker"
      - "agent:ralph/monitor"
      - "agent:ralph/analyzer"
      - "ralph:write_template_prompt"
      - "ralph:write_template_agent"
      - "ralph:write_template_fix_plan"
      - "ralph:write_template_specs_gitkeep"

  # ---------------------------------------------------------------------------
  # Main orchestrator (routes to subcommands)
  # ---------------------------------------------------------------------------
  - name: "ralph"
    display: "Ralph Orchestrator"
    description: "Main entry: routes to import/loop/once/monitor/setup/status/reset commands. Generic iterative orchestrator (self-contained templates)."
    model: "anthropic/L2"
    instruction: |
      You are Ralph, an orchestrator for an autonomous iterative improvement loop.

      You do NOT execute the user's real work directly.
      You coordinate sub-agents that implement the loop machinery and delegate the actual work to `ralph/worker`.

      Supported subcommands (CLI-style flags may appear in the user's message):
        --prompt <file>           default PROMPT.md
        --calls <n>               default 100 (hourly)
        --timeout <minutes>       default 15
        --output-format json|text default json (for analysis expectations)
        --allowed-tools <csv>     optional, a hint for external execution tools
        --no-continue             disable session continuity
        --session-expiry <hours>  default 24
        --reset-session           reset session and exit
        --reset-circuit           reset circuit breaker and exit
        --circuit-status          print circuit state and exit
        --status                  print status.json and exit
        --monitor                 start monitor and then run loop
        --max-loops <n>           default 0 (no explicit cap)
        --once                    run exactly one iteration
        --import <file> [name]    import PRD/spec into project
        --setup <name>            create blank project structure

      Routing rules:
      - If query includes "--import": run ralph/import.
      - Else if query includes "--setup": run ralph/setup.
      - Else if query includes "--monitor" and NOT "--once": start ralph/monitor then run ralph/loop.
      - Else if query includes "--once": run ralph/once.
      - Else if query includes "--status": print status.json (read file; if missing say so).
      - Else if query includes "--circuit-status": print .circuit_breaker_state (read file; if missing say so).
      - Else if query includes "--reset-session": delete .ralph_session and append to .ralph_session_history; then exit.
      - Else if query includes "--reset-circuit": delete .circuit_breaker_state and .circuit_breaker_history; then exit.
      - Otherwise: run ralph/loop.

      State and control files (in CWD unless import/setup creates a new folder):
        PROMPT.md, @fix_plan.md, @AGENT.md, specs/, logs/, docs/generated/
        status.json, progress.json,
        .call_count, .last_reset_hour,
        .exit_signals,
        .response_analysis,
        .circuit_breaker_state, .circuit_breaker_history,
        .ralph_session, .ralph_session_history,
        .agent/scratchpad.md

      Templates (self-contained):
      - This pack embeds canonical template contents.
      - Sub-agents may materialize them into a project directory by calling the provided tools:
          ralph:write_template_prompt
          ralph:write_template_agent
          ralph:write_template_fix_plan
          ralph:write_template_specs_gitkeep

      Constraints:
      - Prefer spawning sub-agents (agent:ralph/*) rather than scripts.
      - Use fs:* tools only for reading/writing these state/control files.

      Output:
      - Provide a brief summary of what path ran and what files were updated.

    functions:
      - "ai:spawn_agent"
      - "fs:*"

  # ---------------------------------------------------------------------------
  # worker: performs one focused work step by selecting/delegating to tools/agents
  # ---------------------------------------------------------------------------
  - name: "worker"
    display: "Ralph Worker"
    description: "Generic worker invoked by Ralph. Performs ONE focused step by delegating to a selected agent/tool; updates .agent/scratchpad.md."
    model: "anthropic/L2"
    functions:
      - "fs:*"
      - "sh:*"
      - "web:*"
      - "ai:*"
    instruction: |
      You are Ralph's generic worker. You are called for EXACTLY ONE iteration.

      Your job is to advance the user's objective by doing ONE small, high-leverage action.
      You may do the work yourself OR delegate to another agent/tool. Prefer delegation when it reduces risk or cost.

      First actions (mandatory):
      1) Read these files if they exist (use fs tools):
         - PROMPT.md (or the file referenced by --prompt in the parent query if provided)
         - @fix_plan.md
         - specs/requirements.md
         - .agent/scratchpad.md
         - status.json and progress.json
         - .response_analysis
         - the newest file in logs/ (if available)
      2) Identify what failed last time (errors, blockers) and what remains.

      Decide what to do this iteration:
      - Choose ONE primary action from this menu:
        A) "implement"   : change project files to make progress on requirements
        B) "diagnose"    : investigate an error/blocker and propose a fix
        C) "test"        : run the minimum necessary checks to validate recent changes
        D) "research"    : gather missing information (web search) required to proceed
        E) "external_run": invoke an external CLI/tool via sh:exec (only if necessary and safe)
        F) "delegate"    : spawn a more specialized agent to do A-D

      Delegation rules (important):
      - If you need code edits across many files, spawn a specialized agent (if available) using ai:spawn_agent.
      - If you need shell execution (tests/build), use sh:exec and capture stdout/stderr.
      - If you need web context, use web:* tools.
      - If the action is ambiguous, perform a brief diagnosis step instead of guessing.

      Output protocol (critical):
      - You MUST finish by writing/overwriting .agent/scratchpad.md with:
        - Iteration timestamp (ISO-like)
        - Goal for this iteration
        - Action chosen (A-F) and why
        - Commands run (if any) and their outputs (summarize)
        - Files changed (list)
        - Observed errors/blockers (verbatim key lines)
        - What remains (next 1-3 steps)
        - Whether you believe the overall objective is complete

      Completion token:
      - If you believe the overall user objective is complete, print exactly: LOOP_COMPLETE
        on its own line as the final line of your response.

      Safety:
      - Do not run destructive commands.
      - Prefer read-only actions when uncertain.

  # ---------------------------------------------------------------------------
  # ralph import: PRD/spec import
  # ---------------------------------------------------------------------------
  - name: "import"
    display: "Ralph Import"
    description: "Imports a PRD/spec into a new project folder (PROMPT.md, @fix_plan.md, specs/requirements.md, @AGENT.md). Uses embedded templates."
    model: "anthropic/L2"
    instruction: |
      You implement the PRD import feature.

      Input (from user query):
      - A source file path to a PRD/spec document
      - Optional project name

      Actions:
      1) Create a new project folder with the standard structure:
         <project>/{PROMPT.md,@fix_plan.md,@AGENT.md,specs/requirements.md,specs/stdlib,src,examples,logs,docs/generated,.agent}
      2) Materialize embedded templates into the project directory by calling tools:
         - ralph:write_template_prompt
         - ralph:write_template_agent
         - ralph:write_template_fix_plan
         - ralph:write_template_specs_gitkeep
      3) Call an LLM once to convert the PRD into:
         - PROMPT.md (instructions customized to the project)
         - @fix_plan.md (prioritized tasks)
         - specs/requirements.md (technical specs)
         Use the marker protocol:
           ===PROMPT.md===
           ...
           ===@fix_plan.md===
           ...
           ===specs/requirements.md===
           ...
      4) Overwrite those three files in the project directory with the converted content.
      5) Ensure <project>/.agent/scratchpad.md exists (create empty if needed).

      Constraints:
      - Pure YAML agents.
      - Use fs tools for file I/O.

      Output:
      - Print the created paths.

    functions:
      - "ralph:write_template_prompt"
      - "ralph:write_template_agent"
      - "ralph:write_template_fix_plan"
      - "ralph:write_template_specs_gitkeep"
      - "ai:call_llm"
      - "fs:*"

  # ---------------------------------------------------------------------------
  # ralph setup: initialize blank project
  # ---------------------------------------------------------------------------
  - name: "setup"
    display: "Ralph Setup"
    description: "Creates a new blank project using embedded templates (no PRD conversion)."
    model: "anthropic/L2"
    parameters:
      type: "object"
      properties:
        root_dir:
          type: "string"
          description: "Optional root directory where the project folder will be created. Defaults to current directory."
        project_name:
          type: "string"
          description: "Name of the new project directory to create."
      required: ["project_name"]
    instruction: |
      #! --mime-type=text/x-go-template
      You implement project setup.

      Inputs (tool parameters):
      - root_dir (optional): {{ default "<no value>" .root_dir }}
      - project_name (required): {{ default "missing" .project_name }}

      Resolve target directory:
      1) If root_dir is empty or "<no value>", call `sh:pwd` and use that as ROOT_DIR.
      2) If project_name is "missing", report error and exit.
      3) PROJECT_DIR := ROOT_DIR + "/" + project_name.

      Do the following steps in order and echo progress:
      1) Print: "ðŸš€ Setting up Ralph project: <project_name>"
      2) Create project directory. If PROJECT_DIR already exists, report error and exit.
      3) Create structure under PROJECT_DIR: specs/stdlib,src,examples,logs,docs/generated,.agent
      4) Materialize embedded templates into PROJECT_DIR by calling tools:
         - ralph:write_template_prompt        (base_dir=PROJECT_DIR) -> PROJECT_DIR/PROMPT.md
         - ralph:write_template_fix_plan      (base_dir=PROJECT_DIR) -> PROJECT_DIR/@fix_plan.md
         - ralph:write_template_agent         (base_dir=PROJECT_DIR) -> PROJECT_DIR/@AGENT.md
         - ralph:write_template_specs_gitkeep (base_dir=PROJECT_DIR) -> PROJECT_DIR/specs/.gitkeep
      5) Ensure PROJECT_DIR/specs/requirements.md exists (create empty file if absent).
      6) Ensure PROJECT_DIR/.agent/scratchpad.md exists (create empty file if absent).
      7) Initialize git in PROJECT_DIR (best-effort):
         - sh:exec "git -C <PROJECT_DIR> init"
         - Write PROJECT_DIR/README.md with "# <project_name>\n"
         - sh:exec "git -C <PROJECT_DIR> add ."
         - sh:exec "git -C <PROJECT_DIR> commit -m \"Initial Ralph project setup\"" (ignore failure if user has no git identity)
      8) Print:
         "âœ… Project <project_name> created!"
         "Next steps:"
         "  1. Edit PROMPT.md with your project requirements"
         "  2. Update specs/ with your project specifications"
         "  3. Run: "agent:ralph/loop"
         "  4. Monitor: "agent:ralph/monitor"

      Output:
      - Return the created PROJECT_DIR path and the key files created.
    message: |
      Set up ralph project.
    functions:
      - "sh:pwd"
      - "sh:exec"
      - "ralph:write_template_prompt"
      - "ralph:write_template_agent"
      - "ralph:write_template_fix_plan"
      - "ralph:write_template_specs_gitkeep"
      - "fs:*"

  # ---------------------------------------------------------------------------
  # ralph loop: multi-iteration runner
  # ---------------------------------------------------------------------------
  - name: "loop"
    display: "Ralph Loop"
    description: "Runs multi-iteration loop with rate limiting, circuit breaker, session continuity, and exit detection."
    model: "anthropic/L2"
    instruction: |
      You run the multi-iteration loop.

      Required behavior:
      - Parse flags from query (same as ralph/ralph).
      - If --monitor present, spawn ralph/monitor first.
      - Then iterate:
        - Spawn ralph/once for each loop.
        - After each iteration, check for graceful exit conditions (dual-condition gate).
        - Stop on circuit breaker OPEN.
        - Respect --max-loops if > 0.

      Exit detection (must match upstream essence):
      - "project_complete" requires BOTH:
          completion_indicators >= 2
          AND last parsed RALPH_STATUS EXIT_SIGNAL == true
      - Other exits:
          3 consecutive test-only loops => exit_reason "test_saturation"
          @fix_plan.md all [x] AND EXIT_SIGNAL true => exit_reason "plan_complete"

      State files in CWD:
        status.json, progress.json, .exit_signals, .response_analysis, .circuit_breaker_state, .ralph_session, .agent/scratchpad.md

    functions:
      - "ai:spawn_agent"
      - "fs:*"

  # ---------------------------------------------------------------------------
  # ralph once: single iteration
  # ---------------------------------------------------------------------------
  - name: "once"
    display: "Ralph Once"
    description: "Runs exactly one iteration: rate limit check, invoke worker, analyze output, update state files."
    model: "anthropic/L2"
    instruction: |
      Run exactly ONE loop iteration.

      Steps:
      1) Load PROMPT.md (or --prompt).
      2) Ensure directories exist: logs/, docs/generated/, .agent/.
      3) Enforce hourly rate limiting using .call_count and .last_reset_hour.
      4) Maintain session lifecycle in .ralph_session and .ralph_session_history:
         - if session is expired (default 24h) or --no-continue, don't carry session.
         - if --reset-session, clear session and return.
      5) Spawn ralph/worker once to perform the actual work for this iteration.
      6) Save raw worker output to logs/worker_output_<timestamp>.log
      7) Spawn ralph/analyzer to parse output and write .response_analysis
      8) Update .exit_signals rolling windows.
      9) Update circuit breaker state file.
      10) Update status.json and progress.json.

      Circuit breaker thresholds (upstream defaults):
        no-progress loops >= 3 => OPEN
        same-error loops >= 5 => OPEN
        no-progress >= 2 => HALF_OPEN
        progress in HALF_OPEN => CLOSED

      "Progress" definition:
      - If parsed analysis reports files_modified > 0 OR tasks_completed > 0.

      Output:
      - Return a concise JSON blob summarizing loop_number, out_file, cb_state.

    functions:
      - "ai:spawn_agent"
      - "fs:*"

  # ---------------------------------------------------------------------------
  # ralph monitor: pure agent dashboard
  # ---------------------------------------------------------------------------
  - name: "monitor"
    display: "Ralph Monitor"
    description: "Shows a live snapshot dashboard by reading status/progress/last log (single-shot, non-tmux)."
    model: "anthropic/L1"
    instruction: |
      Read and summarize (if present):
      - status.json
      - progress.json
      - .circuit_breaker_state
      - .response_analysis
      - .agent/scratchpad.md
      - last N lines of newest file under logs/

      Output a human-readable dashboard once and exit.

    functions:
      - "fs:*"

  # ---------------------------------------------------------------------------
  # analyzer: parse response into normalized JSON
  # ---------------------------------------------------------------------------
  - name: "analyzer"
    display: "Ralph Analyzer"
    description: "Parses the worker output, extracts ---RALPH_STATUS--- block if present, and emits normalized analysis JSON."
    model: "anthropic/L2"
    instruction: |
      Input:
        output_text: raw worker output (string)
        loop_number: integer

      Produce exactly ONE JSON object (no extra text) with:
      {
        "loop_number": <int>,
        "analysis": {
          "has_ralph_status": <bool>,
          "status": "IN_PROGRESS"|"COMPLETE"|"BLOCKED"|"UNKNOWN",
          "tasks_completed": <int>,
          "files_modified": <int>,
          "tests_status": "PASSING"|"FAILING"|"NOT_RUN"|"UNKNOWN",
          "work_type": "IMPLEMENTATION"|"TESTING"|"DOCUMENTATION"|"REFACTORING"|"DEBUGGING"|"UNKNOWN",
          "exit_signal": <bool>,
          "completion_indicators": <int>,
          "is_test_only": <bool>,
          "is_stuck": <bool>,
          "has_progress": <bool>,
          "work_summary": <string>,
          "output_length": <int>
        }
      }

      Parsing rules:
      - Prefer extracting the ---RALPH_STATUS--- block.
      - If missing, fallback to text heuristics:
        - completion indicators: count matches of phrases like "all tasks complete", "done", "finished", "ready for review".
        - test-only: if output mentions only running tests and no implementation.
        - stuck: repeated "error" lines or explicit blocked wording.
      - exit_signal defaults to false if absent.
      - has_progress true if tasks_completed>0 OR files_modified>0.

    functions:
      - "ai:call_llm"

# =============================================================================
# Embedded template materializers (Go tools)
# =============================================================================
kit: "ralph"
type: "func"
tools:
  - name: "write_template_prompt"
    description: "Write the embedded PROMPT.md template to <base_dir>/PROMPT.md (creating directories as needed)."
    parameters:
      type: "object"
      properties:
        base_dir:
          type: "string"
          description: "Project base directory to write into (e.g., /path/to/my-project)."
      required: ["base_dir"]
    body:
      mime_type: "application/x-go"
      script: |
        #! --mime-type=text/x-go-template
        package main

        import (
          "fmt"
          "os"
          "path/filepath"
          "strings"
        )

        var baseDir = "{{.base_dir}}"

        const content = `{{asset "/templates/PROMPT.md"}}`
        func decodeMD(s string) string {
          return strings.ReplaceAll(s, "&grave;", "`")
        }

        func main() {
          if baseDir == "" || baseDir == "<no value>" {
            fmt.Fprintln(os.Stderr, "missing required parameter: base_dir")
            os.Exit(2)
          }
          outPath := filepath.Join(baseDir, "PROMPT.md")
          if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
            fmt.Fprintln(os.Stderr, err.Error())
            os.Exit(1)
          }
          if err := os.WriteFile(outPath, []byte(decodeMD(content)), 0o644); err != nil {
            fmt.Fprintln(os.Stderr, err.Error())
            os.Exit(1)
          }
          fmt.Println(outPath)
        }

  - name: "write_template_agent"
    description: "Write the embedded AGENT.md template to <base_dir>/@AGENT.md (creating directories as needed)."
    parameters:
      type: "object"
      properties:
        base_dir:
          type: "string"
          description: "Project base directory to write into (e.g., /path/to/my-project)."
      required: ["base_dir"]
    body:
      mime_type: "application/x-go"
      script: |
        #! --mime-type=text/x-go-template
        package main

        import (
          "fmt"
          "os"
          "path/filepath"
          "strings"
        )

        var baseDir = "{{.base_dir}}"
        
        const content = `{{asset "/templates/AGENT.md"}}`
        func decodeMD(s string) string {
          return strings.ReplaceAll(s, "&grave;", "`")
        }

        func main() {
          if baseDir == "" || baseDir == "<no value>" {
            fmt.Fprintln(os.Stderr, "missing required parameter: base_dir")
            os.Exit(2)
          }
          outPath := filepath.Join(baseDir, "@AGENT.md")
          if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
            fmt.Fprintln(os.Stderr, err.Error())
            os.Exit(1)
          }
          if err := os.WriteFile(outPath, []byte(decodeMD(content)), 0o644); err != nil {
            fmt.Fprintln(os.Stderr, err.Error())
            os.Exit(1)
          }
          fmt.Println(outPath)
        }

  - name: "write_template_fix_plan"
    description: "Write the embedded fix_plan.md template to <base_dir>/@fix_plan.md (creating directories as needed)."
    parameters:
      type: "object"
      properties:
        base_dir:
          type: "string"
          description: "Project base directory to write into (e.g., /path/to/my-project)."
      required: ["base_dir"]
    body:
      mime_type: "application/x-go"
      script: |
        #! --mime-type=text/x-go-template
        package main

        import (
          "fmt"
          "os"
          "path/filepath"
          "strings"
        )

        var baseDir = "{{.base_dir}}"

        const content = `{{asset "/templates/fix_plan.md"}}`
        func decodeMD(s string) string {
          return strings.ReplaceAll(s, "&grave;", "`")
        }

        func main() {
          if baseDir == "" || baseDir == "<no value>" {
            fmt.Fprintln(os.Stderr, "missing required parameter: base_dir")
            os.Exit(2)
          }
          outPath := filepath.Join(baseDir, "@fix_plan.md")
          if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
            fmt.Fprintln(os.Stderr, err.Error())
            os.Exit(1)
          }
          if err := os.WriteFile(outPath, []byte(decodeMD(content)), 0o644); err != nil {
            fmt.Fprintln(os.Stderr, err.Error())
            os.Exit(1)
          }
          fmt.Println(outPath)
        }

  - name: "write_template_specs_gitkeep"
    description: "Write the embedded templates/specs/.gitkeep to <base_dir>/specs/.gitkeep (creating directories as needed)."
    parameters:
      type: "object"
      properties:
        base_dir:
          type: "string"
          description: "Project base directory to write into (e.g., /path/to/my-project)."
      required: ["base_dir"]
    body:
      mime_type: "application/x-go"
      script: |
        #! --mime-type=text/x-go-template
        package main

        import (
          "fmt"
          "os"
          "path/filepath"
        )

        var baseDir = "{{.base_dir}}"

        const content = `# This file ensures the templates/specs/ directory is tracked by git
        # Remove this file when you add actual template specification files
        `

        func main() {
          if baseDir == "" || baseDir == "<no value>" {
            fmt.Fprintln(os.Stderr, "missing required parameter: base_dir")
            os.Exit(2)
          }
          outPath := filepath.Join(baseDir, "specs", ".gitkeep")
          if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
            fmt.Fprintln(os.Stderr, err.Error())
            os.Exit(1)
          }
          if err := os.WriteFile(outPath, []byte(content), 0o644); err != nil {
            fmt.Fprintln(os.Stderr, err.Error())
            os.Exit(1)
          }
          fmt.Println(outPath)
        }

# =============================================================================
# No custom models: pure agents + built-in functions
# =============================================================================
