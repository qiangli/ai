###
# =============================================================================
# Embedded template materializers (Go tools)
# =============================================================================
kit: "ralph"
type: "func"
tools:
  - name: "help_import"
    description: "Show usage/help for ralph/import (PRD/spec â†’ Ralph project)"
    parameters:
      type: "object"
      properties: {}
      required: []
    body:
      mime_type: "application/x-go"
      script: |
        package main

        import "fmt"

        func main() {
          fmt.Print(`Ralph Import - Convert PRDs to Ralph Format

        Usage (agent tool call):
          agent:ralph/import --source_file "<path>" --project_name "<name>" --base_dir "<optional>"

        Parameters:
          source_file   Path to your PRD/specification file (any format). Required.
          project_name  Name for the new Ralph project directory. Required.
          base_dir      Directory where the project folder will be created. Optional; defaults to current working directory.

        Examples:
          agent:ralph/import --source_file "my-app-prd.md" --project_name "my-awesome-app"
          agent:ralph/import --base_dir "/tmp" --source_file "requirements.txt" --project_name "webapp"

        Supported formats:
          - Markdown (.md)
          - Text files (.txt)
          - JSON (.json)
          - Word documents (.docx)
          - PDFs (.pdf)
          - Any text-based format

        What this agent will do:
          1) Create a new Ralph project directory under base_dir/project_name
          2) Copy the source_file into the new project directory (basename only)
          3) Convert the PRD into:
            - PROMPT.md (Ralph instructions)
            - @fix_plan.md (prioritized tasks)
            - specs/requirements.md (technical specs)

        Tip:
          If required parameters are missing, call the tool ralph:help_import to see this help text.
        `)
        }

  - name: "spawn_agent"
    description: |
      Spawn agent with automatic retry and cross-provider model alias fallback when the requested model fails.
    parameters:
      type: "object"
      properties:
        agent:
          type: "string"
          description: "The name of the agent"
        query:
          type: "string"
          description: "The user query string"
      required:
        - "agent"
        - "query"
    body:
      mime_type: "application/x-sh"
      script: |
        #! --mime-type=text/x-go-template
        /flow:fallback --actions "[ai:spawn_agent,agent:agent/spawn]" \
          --agent "{{.agent}}" \
          --agent-name "{{.agent}}" \
          --model "anthropic/L1" \
          --query "{{.query}}"
    functions:
      - "fs:*"
      - "sh:*"

  - name: "write_template_prompt"
    description: "Write the embedded PROMPT.md template to <base_dir>/PROMPT.md (creating directories as needed)."
    parameters:
      type: "object"
      properties:
        base_dir:
          type: "string"
          description: "Project base directory to write into (e.g., /path/to/my-project)."
      required: ["base_dir"]
    body:
      mime_type: "application/x-go"
      script: |
        #! --mime-type=text/x-go-template
        package main

        import (
          "fmt"
          "os"
          "path/filepath"
          "strings"
        )

        var baseDir = "{{.base_dir}}"

        const content = `{{asset "/templates/PROMPT.md"}}`
        func decodeMD(s string) string {
          return strings.ReplaceAll(s, "&grave;", "`")
        }

        func main() {
          if baseDir == "" || baseDir == "<no value>" {
            fmt.Println("missing base_dir")
            os.Exit(1)
          }
          if err := os.MkdirAll(baseDir, 0o755); err != nil {
            fmt.Printf("failed to create base_dir: %v\n", err)
            os.Exit(1)
          }
          out := filepath.Join(baseDir, "PROMPT.md")
          if err := os.WriteFile(out, []byte(decodeMD(content)), 0o644); err != nil {
            fmt.Printf("failed to write template: %v\n", err)
            os.Exit(1)
          }
          fmt.Printf("wrote %s\n", out)
        }

  - name: "write_template_agent"
    description: "Write the embedded @AGENT.md template to <base_dir>/@AGENT.md (creating directories as needed)."
    parameters:
      type: "object"
      properties:
        base_dir:
          type: "string"
          description: "Project base directory to write into (e.g., /path/to/my-project)."
      required: ["base_dir"]
    body:
      mime_type: "application/x-go"
      script: |
        #! --mime-type=text/x-go-template
        package main

        import (
          "fmt"
          "os"
          "path/filepath"
          "strings"
        )

        var baseDir = "{{.base_dir}}"

        const content = `{{asset "/templates/@AGENT.md"}}`
        func decodeMD(s string) string {
          return strings.ReplaceAll(s, "&grave;", "`")
        }

        func main() {
          if baseDir == "" || baseDir == "<no value>" {
            fmt.Println("missing base_dir")
            os.Exit(1)
          }
          if err := os.MkdirAll(baseDir, 0o755); err != nil {
            fmt.Printf("failed to create base_dir: %v\n", err)
            os.Exit(1)
          }
          out := filepath.Join(baseDir, "@AGENT.md")
          if err := os.WriteFile(out, []byte(decodeMD(content)), 0o644); err != nil {
            fmt.Printf("failed to write template: %v\n", err)
            os.Exit(1)
          }
          fmt.Printf("wrote %s\n", out)
        }

  - name: "write_template_fix_plan"
    description: "Write the embedded @fix_plan.md template to <base_dir>/@fix_plan.md (creating directories as needed)."
    parameters:
      type: "object"
      properties:
        base_dir:
          type: "string"
          description: "Project base directory to write into (e.g., /path/to/my-project)."
      required: ["base_dir"]
    body:
      mime_type: "application/x-go"
      script: |
        #! --mime-type=text/x-go-template
        package main

        import (
          "fmt"
          "os"
          "path/filepath"
          "strings"
        )

        var baseDir = "{{.base_dir}}"

        const content = `{{asset "/templates/@fix_plan.md"}}`
        func decodeMD(s string) string {
          return strings.ReplaceAll(s, "&grave;", "`")
        }

        func main() {
          if baseDir == "" || baseDir == "<no value>" {
            fmt.Println("missing base_dir")
            os.Exit(1)
          }
          if err := os.MkdirAll(baseDir, 0o755); err != nil {
            fmt.Printf("failed to create base_dir: %v\n", err)
            os.Exit(1)
          }
          out := filepath.Join(baseDir, "@fix_plan.md")
          if err := os.WriteFile(out, []byte(decodeMD(content)), 0o644); err != nil {
            fmt.Printf("failed to write template: %v\n", err)
            os.Exit(1)
          }
          fmt.Printf("wrote %s\n", out)
        }

  - name: "write_template_specs_gitkeep"
    description: "Write the embedded specs/.gitkeep to <base_dir>/specs/.gitkeep (creating directories as needed)."
    parameters:
      type: "object"
      properties:
        base_dir:
          type: "string"
          description: "Project base directory to write into (e.g., /path/to/my-project)."
      required: ["base_dir"]
    body:
      mime_type: "application/x-go"
      script: |
        #! --mime-type=text/x-go-template
        package main

        import (
          "fmt"
          "os"
          "path/filepath"
          "strings"
        )

        var baseDir = "{{.base_dir}}"

        const content = `{{asset "/templates/specs/.gitkeep"}}`
        func decodeMD(s string) string {
          return strings.ReplaceAll(s, "&grave;", "`")
        }

        func main() {
          if baseDir == "" || baseDir == "<no value>" {
            fmt.Println("missing base_dir")
            os.Exit(1)
          }
          specsDir := filepath.Join(baseDir, "specs")
          if err := os.MkdirAll(specsDir, 0o755); err != nil {
            fmt.Printf("failed to create specs dir: %v\n", err)
            os.Exit(1)
          }
          out := filepath.Join(specsDir, ".gitkeep")
          if err := os.WriteFile(out, []byte(decodeMD(content)), 0o644); err != nil {
            fmt.Printf("failed to write template: %v\n", err)
            os.Exit(1)
          }
          fmt.Printf("wrote %s\n", out)
        }
###