#!/usr/bin/env ai /agent:manus/scripts_init_session --script

# https://github.com/OthmanAdi/planning-with-files
# - /scripts/init-session.sh
# - /scripts/check-complete.sh
# - /scripts/session-catchup.py

###
pack: "manus"

agents:
  - name: "scripts_init_session"
    display: "ðŸ§© Manus: Init Session (files)"
    description: |
      Pure-YAML agent version of scripts/init-session.sh.

      Creates planning files in the current working directory if missing:
      - task_plan.md
      - findings.md
      - progress.md

      Prints the same messages as the shell script.

      Parameter:
      - project_name (optional, default "project")

      Output:
      - Console by default.
      - Or write the console output to an absolute path if you invoke with output="file:/abs/path".
    model: "default/any"
    parameters:
      type: "object"
      properties:
        project_name:
          type: "string"
          description: "Project name (default: project)."
        output:
          type: "string"
          description: "Optional output target. Use file:/absolute/path to write the console output."
      required: []
    functions:
      - "fs:*"
      - "sh:*"
    instruction: |
      #! mime-type=text/x-go-template
      You are implementing the exact behavior of `scripts/init-session.sh` but as a pure YAML agent.

      Requirements:
      - Create files only if they do NOT already exist.
      - The file contents must match the script templates exactly.
      - Print the same messages/lines as the script (including blank lines).
      - If output is provided as "file:/abs/path", write the exact console output to that file (and still print it).

      Inputs:
      - project_name: {{ .project_name }}
      - output: {{ .output }}

      Steps:
      1) Determine PROJECT_NAME = project_name if non-empty else "project".
      2) Determine DATE as YYYY-MM-DD using shell `date +%Y-%m-%d`.
      3) Build an output log string that begins with:
         "Initializing planning files for: <PROJECT_NAME>\n"
      4) For each of the 3 files, do:
         - If file exists: append "<file> already exists, skipping\n".
         - Else: write the exact template content to the file and append "Created <file>\n".
      5) Append exactly:
         "\nPlanning files initialized!\nFiles: task_plan.md, findings.md, progress.md\n"
      6) Print the output log string.
      7) If output starts with "file:", write the output log string to that absolute path.

      File templates (must match scripts/init-session.sh):

      task_plan.md (literal, do not substitute variables):
      ---
      # Task Plan: [Brief Description]

      ## Goal
      [One sentence describing the end state]

      ## Current Phase
      Phase 1

      ## Phases

      ### Phase 1: Requirements & Discovery
      - [ ] Understand user intent
      - [ ] Identify constraints
      - [ ] Document in findings.md
      - **Status:** in_progress

      ### Phase 2: Planning & Structure
      - [ ] Define approach
      - [ ] Create project structure
      - **Status:** pending

      ### Phase 3: Implementation
      - [ ] Execute the plan
      - [ ] Write to files before executing
      - **Status:** pending

      ### Phase 4: Testing & Verification
      - [ ] Verify requirements met
      - [ ] Document test results
      - **Status:** pending

      ### Phase 5: Delivery
      - [ ] Review outputs
      - [ ] Deliver to user
      - **Status:** pending

      ## Decisions Made
      | Decision | Rationale |
      |----------|-----------|

      ## Errors Encountered
      | Error | Resolution |
      |-------|------------|
      ---

      findings.md (literal):
      ---
      # Findings & Decisions

      ## Requirements
      -

      ## Research Findings
      -

      ## Technical Decisions
      | Decision | Rationale |
      |----------|-----------|

      ## Issues Encountered
      | Issue | Resolution |
      |-------|------------|

      ## Resources
      -
      ---

      progress.md (DATE substituted in 2 places exactly like the shell heredoc):
      ---
      # Progress Log

      ## Session: <DATE>

      ### Current Status
      - **Phase:** 1 - Requirements & Discovery
      - **Started:** <DATE>

      ### Actions Taken
      -

      ### Test Results
      | Test | Expected | Actual | Status |
      |------|----------|--------|--------|

      ### Errors
      | Error | Resolution |
      |-------|------------|
      ---

      Tooling:
      - Use fs:get_file_info or fs:read_file to check existence (do not fail if missing).
      - Use fs:write_file to create missing files.
      - Use sh:exec for DATE.

      Return value:
      - Your final assistant message should contain ONLY the output log string.

  - name: "scripts_check_complete"
    display: "âœ… Manus: Check Complete"
    description: |
      Pure-YAML agent version of scripts/check-complete.sh.

      Reads a task_plan.md (default task_plan.md) and prints the same completion summary.
      If not complete, it must indicate not complete.

      Note: tools can't set process exit codes. This agent replicates behavior by:
      - printing identical text
      - and returning a final line "EXIT_CODE: 0" or "EXIT_CODE: 1".

      Parameter:
      - plan_file (optional, default task_plan.md)

      Output:
      - Console by default.
      - Or write the console output to an absolute path if you invoke with output="file:/abs/path".
    model: "default/any"
    parameters:
      type: "object"
      properties:
        plan_file:
          type: "string"
          description: "Path to task_plan.md (defaults to task_plan.md in current working directory)."
        output:
          type: "string"
          description: "Optional output target. Use file:/absolute/path to write the console output."
      required: []
    functions:
      - "fs:*"
    instruction: |
      #! mime-type=text/x-go-template
      You are implementing the exact behavior of `scripts/check-complete.sh` but as a pure YAML agent.

      Inputs:
      - plan_file: {{ .plan_file }}
      - output: {{ .output }}

      Behavior:
      1) PLAN_FILE = plan_file if non-empty else "task_plan.md".
      2) If PLAN_FILE does not exist:
         - Print exactly:
           "ERROR: <PLAN_FILE> not found\nCannot verify completion without a task plan.\n"
         - Also append "EXIT_CODE: 1" on its own line.
         - If output starts with "file:", write the same full output to that file.
         - Stop.
      3) Otherwise read the whole PLAN_FILE.
      4) Count occurrences (fixed substring match) like the bash script:
         - TOTAL = count of substring "### Phase"
         - COMPLETE = count of substring "**Status:** complete"
         - IN_PROGRESS = count of substring "**Status:** in_progress"
         - PENDING = count of substring "**Status:** pending"
      5) Print exactly:
         === Task Completion Check ===

         Total phases:   <TOTAL>
         Complete:       <COMPLETE>
         In progress:    <IN_PROGRESS>
         Pending:        <PENDING>

         If COMPLETE == TOTAL and TOTAL > 0:
           ALL PHASES COMPLETE
           EXIT_CODE: 0
         else:
           TASK NOT COMPLETE

           Do not stop until all phases are complete.
           EXIT_CODE: 1
      6) If output starts with "file:", write the same full output to that file.

      Tooling:
      - Use fs:get_file_info to check existence.
      - Use fs:read_file to read content.
      - Use template/string processing in your reasoning; ensure substring counts are correct.
      - Use fs:write_file for output file if requested.

      Return value:
      - Your final assistant message should contain ONLY the printed output.

  - name: "session_catchup"
    display: "ðŸ§­ Manus: Session Catchup"
    description: |
      Pure-YAML agent version of scripts/session-catchup.py.

      It inspects the previous Claude session jsonl file under:
      ~/.claude/projects/<sanitized-project-path>/*.jsonl (excluding agent-*.jsonl)

      If it finds "unsynced" context after the last planning file update, it prints the catchup report.
      Otherwise it prints nothing.

      Parameter:
      - project_path (optional, default current working directory)

      Output:
      - Console by default.
      - Or write the console output to an absolute path if you invoke with output="file:/abs/path".
    model: "default/any"
    parameters:
      type: "object"
      properties:
        project_path:
          type: "string"
          description: "Project path used to locate ~/.claude/projects/<sanitized>/ session logs (defaults to current working directory)."
        output:
          type: "string"
          description: "Optional output target. Use file:/absolute/path to write the console output."
      required: []
    functions:
      - "fs:*"
      - "sh:*"
    instruction: |
      #! mime-type=text/x-go-template
      You are implementing the exact behavior of `scripts/session-catchup.py` but as a pure YAML agent.

      Inputs:
      - project_path: {{ .project_path }}
      - output: {{ .output }}

      Behavior (match python script):
      1) Determine PROJECT_PATH = project_path if non-empty else current working directory.
      2) Compute sanitized = PROJECT_PATH with:
         - replace '/' with '-'
         - ensure it starts with '-' (prepend if needed)
         - replace '_' with '-'
      3) PROJECT_DIR = $HOME/.claude/projects/<sanitized>
      4) If PROJECT_DIR does not exist: output nothing (empty).
      5) List files in PROJECT_DIR matching "*.jsonl" excluding those whose basename starts with "agent-".
      6) Sort by modification time descending (newest first).
      7) Pick the first file with size > 5000 bytes. If none, output nothing.
      8) Parse JSONL lines; keep only lines that are valid JSON. Preserve their line number index (0-based) as _line_num.
      9) Find last planning update:
         - Scan messages in order; when message.type == "assistant":
           inspect message.message.content (list). For any item with {type:"tool_use"} and name in ("Write","Edit"),
           if input.file_path endswith any of: task_plan.md, progress.md, findings.md,
           then record last_update_line = that message's _line_num and last_update_file = the planning filename.
      10) Extract messages after:
          - if last_update_line < 0: after_line = len(messages) - 30
          - else after_line = last_update_line
          Use these filters:
          - include only user messages where type=="user" and isMeta==false.
            Content may be string or list; if list, take first item of type=="text" and use its "text".
            Skip if content starts with any of: "<local-command", "<command-", "<task-notification".
            Include only if len(content) > 20.
          - include assistant messages where type=="assistant".
            Collect text_content (from string or from items of type=="text", keep last seen),
            and tool_uses (from items type=="tool_use") formatted exactly:
              - Edit -> "Edit: <file_path or unknown>"
              - Write -> "Write: <file_path or unknown>"
              - Bash -> "Bash: <command[:80]>"
              - else -> "<tool_name>"
            Include the message if text_content or tool_uses exist.
            Truncate text_content to 600 chars.
            Store role="assistant" and line=_line_num.
      11) If no extracted messages: output nothing.
      12) Otherwise print the report exactly like python:

          \n[planning-with-files] SESSION CATCHUP DETECTED
          Previous session: <target_session.stem>

          If last_update_line >= 0:
            Last planning update: <last_update_file> at message #<last_update_line>
            Unsynced messages: <len(messages_after)>
          else:
            No planning file updates found in previous session

          \n--- UNSYNCED CONTEXT ---
          Then for the last 15 extracted messages:
            - if role==user: print "USER: <content[:300]>"
            - else: if content exists print "CLAUDE: <content[:300]>"
                    if tools exist print "  Tools: <join tools[:4] with ', '>"

          \n--- RECOMMENDED ---
          1. Run: git diff --stat
          2. Read: task_plan.md, progress.md, findings.md
          3. Update planning files based on above context
          4. Continue with task

      13) If output starts with "file:", write the same report text to that file.
      14) If there is no report (empty), do not create/write the output file.

      Tooling:
      - Use sh:exec for $HOME and for current working directory if needed.
      - Use fs:list_directory + fs:get_file_info to gather mod times and sizes.
      - Use fs:read_file to read jsonl.

      Return value:
      - Your final assistant message should contain ONLY the report text (or empty).
