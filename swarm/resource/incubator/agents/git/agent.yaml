#!/usr/bin/env ai
#
# Agent-first Git suite (fully mechanical orchestrator).
#
# Main entry: agent:git/git
# - Deterministic routing only.
# - No ai:call_llm.
# - Freeform text is classified via sh:classifier (rule-based Go tool).
#
pack: "git"
agents:
  - name: "git"
    display: "Git Orchestrator (Mechanical)"
    description: "Deterministic routing to git sub-agents; freeform classified via sh:classifier (no LLM)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        id: { type: "string" }
        user: { type: "string" }
        payload:
          type: "object"
          properties:
            action: { type: "string" }
            dir: { type: "string" }
            args: { type: "array", items: { type: "string" } }
            message: { type: "string" }
            rev: { type: "string" }
            path: { type: "string" }
            query: { type: "string" }
        # Backward compat:
        action: { type: "string" }
        dir: { type: "string" }
        args: { type: "array", items: { type: "string" } }
        message: { type: "string" }
        rev: { type: "string" }
        path: { type: "string" }
        query: { type: "string" }
      required: []
    instruction: |
      You are a fully mechanical Git orchestrator.

      Never call ai:call_llm.

      Input forms you may receive:
      - Structured: {payload:{action,dir,args,message,rev,path}}
      - Backward compat structured: {action,dir,args,message,rev,path}
      - Freeform: {payload:{query:"..."}} or {query:"..."}

      Routing rules:
      1) Extract the effective payload:
         - If payload exists, use it.
         - Otherwise build payload from top-level action/dir/args/message/rev/path/query.

      2) If payload.action is non-empty:
         - Route deterministically by spawning the matching sub-agent:
           status -> agent:git/status
           commit -> agent:git/commit
           pull -> agent:git/pull
           push -> agent:git/push
           branches -> agent:git/branches
           log -> agent:git/log
           show -> agent:git/show
           diff -> agent:git/diff
           diff_staged -> agent:git/diff_staged
           diff_unstaged -> agent:git/diff_unstaged
           add -> agent:git/add
           reset -> agent:git/reset
           checkout -> agent:git/checkout
           create_branch -> agent:git/create_branch
           tag -> agent:git/tag

      3) Else if payload.query is non-empty:
         - Call sh:classifier with the query to obtain {action,dir,args,message,confidence}.
         - If confidence < 0.7 OR action is empty:
           return a JSON object asking ONE clarifying question, like:
             {
               "ok": false,
               "needs_clarification": true,
               "question": "I couldn't determine the git action. Please specify one of: status, commit, pull, push, branches, log, show, diff, diff_staged, diff_unstaged, add, reset, checkout, create_branch, tag. Also include repo dir if needed.",
               "classifier": { ...full classifier output... }
             }
           and STOP.
         - Otherwise, route to the chosen sub-agent using the classifier outputs as the payload.

      4) Else:
         return a JSON error telling the user to provide action or query.

      Output requirements:
      - For successful operations, return the sub-agent's output as-is.
      - For clarification requests, return the structured clarification JSON described above.
    functions:
      - "ai:spawn_agent"
      - "sh:classifier"
      - "agent:git/status"
      - "agent:git/commit"
      - "agent:git/pull"
      - "agent:git/push"
      - "agent:git/branches"
      - "agent:git/log"
      - "agent:git/show"
      - "agent:git/diff"
      - "agent:git/diff_staged"
      - "agent:git/diff_unstaged"
      - "agent:git/add"
      - "agent:git/reset"
      - "agent:git/checkout"
      - "agent:git/create_branch"
      - "agent:git/tag"

  - name: "status"
    display: "git status"
    description: "Deterministic git status (tool wrapper)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        dir: { type: "string" }
      required: ["dir"]
    instruction: |
      Call git:status with {dir}.
      Return the tool output as-is.
    functions: ["git:status"]

  - name: "commit"
    display: "git commit"
    description: "Deterministic git commit (tool wrapper)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        dir: { type: "string" }
        message: { type: "string" }
        args: { type: "array", items: { type: "string" } }
      required: ["dir", "message"]
    instruction: |
      Call git:commit with {dir,message,args}.
      Return the tool output as-is.
    functions: ["git:commit"]

  - name: "pull"
    display: "git pull"
    description: "Deterministic git pull (tool wrapper)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        dir: { type: "string" }
        remote: { type: "string" }
        branch: { type: "string" }
      required: ["dir"]
    instruction: |
      Call git:pull with {dir,remote,branch}.
      Return the tool output as-is.
    functions: ["git:pull"]

  - name: "push"
    display: "git push"
    description: "Deterministic git push (tool wrapper)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        dir: { type: "string" }
        remote: { type: "string" }
        branch: { type: "string" }
        push_tags: { type: "boolean" }
      required: ["dir"]
    instruction: |
      Call git:push with {dir,remote,branch,push_tags}.
      Return the tool output as-is.
    functions: ["git:push"]

  - name: "branches"
    display: "git branches"
    description: "List branches (tool wrapper)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        dir: { type: "string" }
        scope: { type: "string", description: "local|remote|all" }
      required: ["dir"]
    instruction: |
      Call git:branches with {dir,scope}.
      Return the tool output as-is.
    functions: ["git:branches"]

  - name: "log"
    display: "git log"
    description: "Show commit logs (tool wrapper)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        dir: { type: "string" }
        since: { type: "string" }
        until: { type: "string" }
        limit: { type: "integer" }
      required: ["dir"]
    instruction: |
      Call git:log with {dir,since,until,limit}.
      Return the tool output as-is.
    functions: ["git:log"]

  - name: "show"
    display: "git show"
    description: "Show a revision/commit (tool wrapper)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        dir: { type: "string" }
        revision: { type: "string" }
      required: ["dir", "revision"]
    instruction: |
      Call git:show with {dir,revision}.
      Return the tool output as-is.
    functions: ["git:show"]

  - name: "diff"
    display: "git diff"
    description: "Diff vs target (tool wrapper)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        dir: { type: "string" }
        target: { type: "string" }
        context_lines: { type: "integer" }
      required: ["dir", "target"]
    instruction: |
      Call git:diff with {dir,target,context_lines}.
      Return the tool output as-is.
    functions: ["git:diff"]

  - name: "diff_staged"
    display: "git diff --cached"
    description: "Diff staged (tool wrapper)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        dir: { type: "string" }
        context_lines: { type: "integer" }
      required: ["dir"]
    instruction: |
      Call git:diff_staged with {dir,context_lines}.
      Return the tool output as-is.
    functions: ["git:diff_staged"]

  - name: "diff_unstaged"
    display: "git diff"
    description: "Diff unstaged (tool wrapper)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        dir: { type: "string" }
        context_lines: { type: "integer" }
      required: ["dir"]
    instruction: |
      Call git:diff_unstaged with {dir,context_lines}.
      Return the tool output as-is.
    functions: ["git:diff_unstaged"]

  - name: "add"
    display: "git add"
    description: "Stage files (tool wrapper)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        dir: { type: "string" }
        files: { type: "array", items: { type: "string" } }
      required: ["dir", "files"]
    instruction: |
      Call git:add with {dir,files}.
      Return the tool output as-is.
    functions: ["git:add"]

  - name: "reset"
    display: "git reset"
    description: "Unstage changes (tool wrapper)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        dir: { type: "string" }
      required: ["dir"]
    instruction: |
      Call git:reset with {dir}.
      Return the tool output as-is.
    functions: ["git:reset"]

  - name: "checkout"
    display: "git checkout"
    description: "Checkout branch (tool wrapper)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        dir: { type: "string" }
        branch: { type: "string" }
      required: ["dir", "branch"]
    instruction: |
      Call git:checkout with {dir,branch}.
      Return the tool output as-is.
    functions: ["git:checkout"]

  - name: "create_branch"
    display: "git branch <new>"
    description: "Create branch (tool wrapper)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        dir: { type: "string" }
        name: { type: "string" }
        base_branch: { type: "string" }
      required: ["dir", "name"]
    instruction: |
      Call git:create_branch with {dir,name,base_branch}.
      Return the tool output as-is.
    functions: ["git:create_branch"]

  - name: "tag"
    display: "git tag"
    description: "Create tag (tool wrapper)."
    model: "default/any"
    parameters:
      type: "object"
      properties:
        dir: { type: "string" }
        tag_name: { type: "string" }
        revision: { type: "string" }
      required: ["dir", "tag_name"]
    instruction: |
      Call git:tag with {dir,tag_name,revision}.
      Return the tool output as-is.
    functions: ["git:tag"]
