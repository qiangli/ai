#!/usr/bin/env ai
#
# Tool: sh:git
#
# It is intentionally strict: it only accepts structured actions or a command
# array that starts with "git".
#
# Runtime notes:
# - Default uses `go run` from the workspace root.
# - No static binaries are checked in. (You may build one locally if desired.)
#
kit: "sh"
tools:
  - name: "git"
    description: "Run safe git actions."
    type: "func"
    parameters:
      type: "object"
      properties:
        id: { type: "string", description: "Optional request id." }
        user: { type: "string", description: "Optional user label." }
        payload:
          type: "object"
          description: "Payload object passed to git. If omitted, tool will build it from top-level fields for backward compat."
          properties:
            action:
              type: "string"
              enum: ["status","clone","commit","pull","push","branch","remote-url","rev-parse","list-branches","list-remotes","latest-commit","show-file","raw"]
            dir: { type: "string" }
            args: { type: "array", items: { type: "string" } }
            message: { type: "string" }
            rev: { type: "string" }
            path: { type: "string" }
            command:
              type: "array"
              items: { type: "string" }
              description: "Raw git argv array; must start with 'git'."
        # Backward-compat convenience fields:
        action:
          type: "string"
          enum: ["status","clone","commit","pull","push","branch","remote-url","rev-parse","list-branches","list-remotes","latest-commit","show-file","raw"]
        dir: { type: "string" }
        args: { type: "array", items: { type: "string" } }
        message: { type: "string" }
        rev: { type: "string" }
        path: { type: "string" }
        command:
          type: "array"
          items: { type: "string" }
      required: []
    body:
      mime_type: "application/x-go"
      script: |
        #! --mime-type=text/x-go-template
        package main

        import (
          "bytes"
          "encoding/json"
          "fmt"
          "os"
          "strings"

          "github.com/qiangli/ai/swarm/atm/gitkit"
        )

        // Top-level fields (strings) injected by the runtime.
        var id = "<no value>"
        var user = "<no value>"
        var payload = "<no value>" // JSON object

        var action = "<no value>"
        var dir = "<no value>"
        var args = "<no value>"   // JSON array
        var message = "<no value>"
        var rev = "<no value>"
        var path = "<no value>"
        var command = "<no value>" // JSON array

        type payloadObj struct {
          Action  string   `json:"action,omitempty"`
          Dir     string   `json:"dir,omitempty"`
          Args    []string `json:"args,omitempty"`
          Message string   `json:"message,omitempty"`
          Rev     string   `json:"rev,omitempty"`
          Path    string   `json:"path,omitempty"`
          Command []string `json:"command,omitempty"`
        }

        type envelope struct {
          ID      string     `json:"id,omitempty"`
          User    string     `json:"user,omitempty"`
          Payload payloadObj `json:"payload"`
        }

        func main() {
          var env envelope
          if id != "" && id != "<no value>" { env.ID = id }
          if user != "" && user != "<no value>" { env.User = user }

          // Prefer explicit payload.
          if payload != "" && payload != "<no value>" {
            if err := json.Unmarshal([]byte(payload), &env.Payload); err != nil {
              fmt.Fprintf(os.Stderr, "invalid payload JSON: %v\n", err)
              os.Exit(2)
            }
          } else {
            // Build from top-level convenience fields.
            if action != "" && action != "<no value>" { env.Payload.Action = action }
            if dir != "" && dir != "<no value>" { env.Payload.Dir = dir }
            if message != "" && message != "<no value>" { env.Payload.Message = message }
            if rev != "" && rev != "<no value>" { env.Payload.Rev = rev }
            if path != "" && path != "<no value>" { env.Payload.Path = path }

            if args != "" && args != "<no value>" {
              var list []string
              if err := json.Unmarshal([]byte(args), &list); err != nil {
                fmt.Fprintf(os.Stderr, "invalid args JSON: %v\n", err)
                os.Exit(2)
              }
              env.Payload.Args = list
            }
            if command != "" && command != "<no value>" {
              var list []string
              if err := json.Unmarshal([]byte(command), &list); err != nil {
                fmt.Fprintf(os.Stderr, "invalid command JSON: %v\n", err)
                os.Exit(2)
              }
              env.Payload.Command = list
            }
          }

          // Basic validation before invoking.
          if len(env.Payload.Command) > 0 {
            if env.Payload.Command[0] != "git" {
              fmt.Fprintf(os.Stderr, "command must start with 'git'\n")
              os.Exit(2)
            }
          } else {
            a := strings.TrimSpace(env.Payload.Action)
            if a == "" {
              fmt.Fprintf(os.Stderr, "either payload.command or payload.action is required\n")
              os.Exit(2)
            }
          }

          // Now dispatch using gitkit directly to avoid spawning external processes.
          out := run(env.Payload)
          enc := json.NewEncoder(os.Stdout)
          enc.SetEscapeHTML(false)
          _ = enc.Encode(out)
          if !out.OK {
            // Use a non-zero exit code when tool reported error.
            os.Exit(out.ExitCode)
          }
        }

        type Output struct {
          ID       string `json:"id,omitempty"`
          User     string `json:"user,omitempty"`
          Stdout   string `json:"stdout"`
          Stderr   string `json:"stderr"`
          ExitCode int    `json:"exit_code"`
          OK       bool   `json:"ok"`
          Error    string `json:"error,omitempty"`
        }

        func run(p payloadObj) Output {
          // Raw command mode.
          if len(p.Command) > 0 {
            stdout, stderr, code, err := gitkit.RunGitExitCode(p.Dir, p.Command[1:]...)
            out := Output{Stdout: stdout, Stderr: stderr, ExitCode: code, OK: err == nil}
            if err != nil {
              out.Error = err.Error()
            }
            return out
          }

          action := strings.ToLower(strings.TrimSpace(p.Action))
          switch action {
          case "status":
            outStr, errStr, err := gitkit.Status(p.Dir)
            out := Output{Stdout: outStr, Stderr: errStr, ExitCode: 0, OK: err == nil}
            if err != nil { out.ExitCode = 1; out.Error = err.Error() }
            return out
          case "clone":
            if len(p.Args) != 2 {
              return Output{ExitCode: 2, OK: false, Error: "clone requires args: [repoURL, destDir]"}
            }
            err := gitkit.Clone(p.Args[0], p.Args[1])
            if err != nil { return Output{ExitCode: 1, OK: false, Error: err.Error()} }
            return Output{ExitCode: 0, OK: true}
          case "commit":
            msg := strings.TrimSpace(p.Message)
            if msg == "" && len(p.Args) > 0 { msg = strings.Join(p.Args, " ") }
            if strings.TrimSpace(msg) == "" {
              return Output{ExitCode: 2, OK: false, Error: "commit requires non-empty message"}
            }
            stdout, stderr, code, err := gitkit.RunGitExitCode(p.Dir, "commit", "-m", msg)
            out := Output{Stdout: stdout, Stderr: stderr, ExitCode: code, OK: err == nil}
            if err != nil { out.Error = err.Error() }
            return out
          case "pull":
            stdout, stderr, code, err := gitkit.RunGitExitCode(p.Dir, append([]string{"pull"}, p.Args...)...)
            out := Output{Stdout: stdout, Stderr: stderr, ExitCode: code, OK: err == nil}
            if err != nil { out.Error = err.Error() }
            return out
          case "push":
            stdout, stderr, code, err := gitkit.RunGitExitCode(p.Dir, append([]string{"push"}, p.Args...)...)
            out := Output{Stdout: stdout, Stderr: stderr, ExitCode: code, OK: err == nil}
            if err != nil { out.Error = err.Error() }
            return out
          case "branch", "current-branch":
            b, errStr, err := gitkit.CurrentBranch(p.Dir)
            out := Output{Stdout: b, Stderr: errStr, ExitCode: 0, OK: err == nil}
            if err != nil { out.ExitCode = 1; out.Error = err.Error() }
            return out
          case "remote-url":
            u, errStr, err := gitkit.RemoteURL(p.Dir)
            out := Output{Stdout: u, Stderr: errStr, ExitCode: 0, OK: err == nil}
            if err != nil { out.ExitCode = 1; out.Error = err.Error() }
            return out
          case "rev-parse":
            rev := strings.TrimSpace(p.Rev)
            if rev == "" && len(p.Args) == 1 { rev = p.Args[0] }
            if rev == "" { return Output{ExitCode: 2, OK: false, Error: "rev-parse requires rev (field 'rev' or args[0])"} }
            h, errStr, err := gitkit.RevParse(p.Dir, rev)
            out := Output{Stdout: h, Stderr: errStr, ExitCode: 0, OK: err == nil}
            if err != nil { out.ExitCode = 1; out.Error = err.Error() }
            return out
          case "list-branches":
            o, errStr, err := gitkit.ListBranches(p.Dir)
            out := Output{Stdout: o, Stderr: errStr, ExitCode: 0, OK: err == nil}
            if err != nil { out.ExitCode = 1; out.Error = err.Error() }
            return out
          case "list-remotes":
            o, errStr, err := gitkit.ListRemotes(p.Dir)
            out := Output{Stdout: o, Stderr: errStr, ExitCode: 0, OK: err == nil}
            if err != nil { out.ExitCode = 1; out.Error = err.Error() }
            return out
          case "latest-commit":
            o, errStr, err := gitkit.LatestCommit(p.Dir)
            out := Output{Stdout: o, Stderr: errStr, ExitCode: 0, OK: err == nil}
            if err != nil { out.ExitCode = 1; out.Error = err.Error() }
            return out
          case "show-file":
            rev := strings.TrimSpace(p.Rev)
            path := strings.TrimSpace(p.Path)
            if rev == "" && len(p.Args) >= 1 { rev = p.Args[0] }
            if path == "" && len(p.Args) >= 2 { path = p.Args[1] }
            if rev == "" || path == "" { return Output{ExitCode: 2, OK: false, Error: "show-file requires rev and path (fields 'rev' and 'path' or args[0]=rev,args[1]=path)"} }
            o, errStr, err := gitkit.ShowFileAtRev(p.Dir, rev, path)
            out := Output{Stdout: o, Stderr: errStr, ExitCode: 0, OK: err == nil}
            if err != nil { out.ExitCode = 1; out.Error = err.Error() }
            return out
          case "raw":
            if len(p.Args) == 0 { return Output{ExitCode: 2, OK: false, Error: "raw requires args: full git argv including 'git'"} }
            if p.Args[0] != "git" { return Output{ExitCode: 2, OK: false, Error: "raw command must start with 'git'"} }
            stdout, stderr, code, err := gitkit.RunGitExitCode(p.Dir, p.Args[1:]...)
            out := Output{Stdout: stdout, Stderr: stderr, ExitCode: code, OK: err == nil}
            if err != nil { out.Error = err.Error() }
            return out
          default:
            return Output{ExitCode: 2, OK: false, Error: fmt.Sprintf("unsupported action %q", action)}
          }
        }
