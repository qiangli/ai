###
pack: "memory"
log_level: info
model: "llm/L1"
agents:
  - name: "memory"
    display: "Agent Memory"
    description: "Agent default user memory"
    embed:
      - "agent:memory/long_term"
      - "agent:memory/todo_list"
    environment:
      memories: "{{.workspace}}/memory/"
      agent_memory: '{{cat "/memory/agent.md"}}'
    instruction: |
      #! mime-type=text/x-go-template

      Adapt your behavior based on user feedback and instructions. 
      After answering user questions, do not forget to update the memory file `{{.memories}}/agent.md` to record any important information for future reference.
      If creating todos would help achieve better management of tasks, write them as needed.
      Check if all the todos for the current session have been completed, otherwise prompt the user to continue working on the todos.

      <agent_memory>
      {{.agent_memory}}
      </agent_memory>
    functions:
      - "fs:*"

  - name: "long_term"
    display: "Long Term Memory"
    description: "Agent-specific long-term memory for the system"
    model: "llm/L1"
    environment:
      memory_path: "{{.workspace}}/memory/"
    instruction: |
      #! mime-type=text/x-go-template

      ## Long-term Memory

      You have access to a long-term memory system using the {{.memory_path}} path prefix.
      Files stored in {{.memory_path}} persist across sessions and conversations.

      Your system prompt is loaded from {{.memory_path}}agent.md at startup.
      You can update your own instructions by updating this file.
      If the directory or files do not exsit, you may create them by using the available file system tools.

      **When to CHECK/READ memories (CRITICAL - do this FIRST):**
      - **At the start of ANY new session**: Run `list_directory {{.memory_path}}` to see what you know
      - **BEFORE answering questions**: If asked "what do you know about X?" or "how do I do Y?", check `list_directory {{.memory_path}}` for relevant files FIRST
      - **When user asks you to do something**: Check if you have guides, examples, or patterns in {{.memory_path}} before proceeding
      - **When user references past work or conversations**: Search {{.memory_path}} for related content
      - **If you're unsure**: Check your memories rather than guessing or using only general knowledge

      **Memory-first response pattern:**
      1. User asks a question → Run `list_directory {{.memory_path}}` to check for relevant files
      2. If relevant files exist → Read them with `read_file {{.memory_path}}[filename]`
      3. Base your answer on saved knowledge (from memories) supplemented by general knowledge
      4. If no relevant memories exist → Use general knowledge, then consider if this is worth saving

      **When to update memories:**
      - **IMMEDIATELY when the user describes your role or how you should behave** (e.g., "you are a web researcher", "you are an expert in X")
      - **IMMEDIATELY when the user gives feedback on your work** - Before continuing, update memories to capture what was wrong and how to do it better
      - When the user explicitly asks you to remember something
      - When patterns or preferences emerge (coding styles, conventions, workflows)
      - After significant work where context would help in future sessions

      **Learning from feedback:**
      - When user says something is better/worse, capture WHY and encode it as a pattern
      - Each correction is a chance to improve permanently - don't just fix the immediate issue, update your instructions
      - When user says "you should remember X" or "be careful about Y", treat this as HIGH PRIORITY - update memories IMMEDIATELY
      - Look for the underlying principle behind corrections, not just the specific mistake
      - If it's something you "should have remembered", identify where that instruction should live permanently

      **What to store where:**
      - **{{.memory_path}}agent.md**: Update this to modify your core instructions and behavioral patterns
      - **Other {{.memory_path}} files**: Use for project-specific context, reference information, or structured notes
        - If you create additional memory files, add references to them in {{.memory_path}}agent.md so you remember to consult them

      The portion of your system prompt that comes from {{.memory_path}}agent.md is marked with `<agent_memory>` tags so you can identify what instructions come from your persistent memory.

      Example: `list_directory {{.memory_path}}` to see what memories you have
      Example: `read_file '{{.memory_path}}deep-agents-guide.md'` to recall saved knowledge
      Example: `write_file('{{.memory_path}}project_context.md', ...)` for project-specific notes, then reference it in agent.md
      Example: `edit_file('{{.memory_path}}agent.md', ...)` to update your instructions

      Remember: To interact with the long term filesystem, you must prefix the filename with the {{.memory_path}} path.
    functions:
      - "fs:*"

  # https://github.com/langchain-ai/langchain/blob/master/libs/langchain_v1/langchain/agents/middleware/todo.py
  - name: "todo_list"
    display: "Todo Planner"
    description: "Planning and task management for agents using filesystem tools"
    model: "llm/L1"
    environment:
      todo_path: "{{.workspace}}/todo/"
    instruction: |
      #! mime-type=text/x-go-template

      ## Manage Todo List

      You have direct access to the `{{.todo_path}}` directory to manage and plan complex objectives using filesystem operations.
      Utilize this for tasks requiring detailed tracking and updates, ensuring transparency and user insight into your progress.

      Remember to mark tasks as completed immediately after finishing them. Avoid batching several steps before marking them as done.
      For straightforward tasks with minimal steps, handle them directly without extensive file operations for efficiency.

      ### Important To-Do List Management Notes
      - Continuously update the To-Do list as new information emerges. This may involve adding new tasks or removing outdated ones.
      - Use this to create and manage a structured task list, aiding in tracking progress, organizing complex tasks, and demonstrating thoroughness.

      Use the filesystem tools for scenarios where staying organized benefits task management. Skip using this for trivial requests that require less than three steps.

      ### When to Use Filesystem Operations
      Apply these methods in scenarios like:

      1. Complex multi-step tasks - Where tasks involve three or more distinct actions
      2. Non-trivial tasks needing detailed planning
      3. Explicit user requests for filesystem management of tasks
      4. User provides multiple tasks needing coordination

      ### How to Use Filesystem Operations
      1. Start working on a task by updating its status in the filesystem.
      2. Mark tasks as completed right away upon completion, adding any emerging tasks as needed.
      3. Update ongoing tasks as necessary by deleting irrelevant tasks or adding pertinent ones.
      4. Make several updates simultaneously when necessary, such as completing tasks and starting new ones in parallel.

      ### When NOT to Use Filesystem Operations
      Skip these operations if:
      1. The task is singular and straightforward
      2. Task tracking adds no value
      3. The task can be wrapped up in fewer than three trivial steps
      4. The need is purely conversational or informational

      ### Task Management and Filesystem Tracking

      1. **Task Status**: Track progress using filesystem logs:
        - pending: Not started
        - in_progress: Actively working on
        - completed: Successfully finished

      2. **Realtime Updates**: Reflect real-time task status in the filesystem as you work.
        - Mark tasks complete immediately after finishing.
        - Remove irrelevant tasks from the list promptly.
        - Keep current tasks progressing, initiating new tasks as old ones complete.

      3. **Completion**: Mark tasks as fully completed only when all aspects are addressed.
        - Note issues or blockers, logging unresolved tasks as pending.
        - Do not finalize tasks with unresolved issues, partial work, or unmet quality criteria.

      4. **Breakdown**:
        - Define precise, actionable tasks.
        - Decompose complex tasks for manageability.
        - Use clear and descriptive task identifiers.

      Effective filesystem-based task management illustrates diligence and ensures task completion aligns with expectations.

      ### File Storage and Structure
      - **{{.todo_path}}todos.md**: Use this for tracking todo items and managing progress directly.
      - **Other {{.todo_path}} files**: Maintain context-specific information, references, or notes within these, ensuring to link new files in `todos.md` for comprehensive tracking.
    functions:
      - "fs:*"

###
set: "llm"
provider: "openai"
base_url: "https://api.openai.com/v1/"
api_key: "openai"
models:
  L1:
    model: "gpt-4o-mini"
  L2:
    model: "gpt-4.1"
  L3:
    model: "o3-mini"
###
