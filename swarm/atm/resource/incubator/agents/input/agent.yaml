###
pack: "input"
log_level: verbose
agents:
  - name: "input"
    display: "Input Interpreter"
    description: |
      The Command-Line Input Parsing Agent is a robust tool designed to interpret and convert mixed-mode user inputs,
      comprising both command-line arguments and natural language text, into a structured JSON format.
      It excels at identifying conventional `--flag` and `-f` notations, as well as parsing named arguments from free text.
      Specializing in conflict resolution, the agent ensures later arguments override earlier ones, providing the most recent
      and relevant data. With dynamic adaptability, it accommodates various argument sets, making it an essential utility
      for developers and applications needing seamless integration of structured user inputs.
    model: "default/any"
    message: |
      Given the Input JSON with description:
        ```json
        {
          "agent": {
            "shorthand": "a",
            "type": "string",
            "description": "Specify the agent to use. shorthand: @<agent>",
            "value": ""
          },
          "workspace": {
            "shorthand": "w",
            "type": "string",
            "description": "Workspace root path",
            "value": ""
          },
          "arguments": {
            "type": "string",
            "description": "Arguments map in JSON format",
            "value": ""
          },
          "arg": {
            "type": "stringArray",
            "description": "Argument name=value (can be used multiple times)",
            "value": []
          },
          "instruction": {
            "type": "string",
            "description": "System role prompt",
            "value": ""
          },
          "message": {
            "type": "string",
            "description": "User query",
            "value": ""
          },
          "new": {
            "type": "bool",
            "description": "Start a new conversation. max-history=0 and max-span=0",
            "value": false
          },
          "context": {
            "type": "string",
            "description": "Agent for summarizing history",
            "value": ""
          },
          "max-history": {
            "type": "int",
            "description": "Max historic messages to retrieve",
            "value": 3
          },
          "max-span": {
            "type": "int",
            "description": "Historic message retrieval span (minutes)",
            "value": 480
          },
          "max-turns": {
            "type": "int",
            "description": "Max conversation turns",
            "value": 0
          },
          "max-time": {
            "type": "int",
            "description": "Max timeout (seconds)",
            "value": 0
          },
          "format": {
            "type": "string",
            "default": "markdown",
            "description": "Output as raw, text, json, or markdown",
            "value": "markdown"
          },
          "log-level": {
            "type": "string",
            "description": "Log level: quiet, info, verbose, trace",
            "value": ""
          },
          "quiet": {
            "type": "bool",
            "description": "Operate quietly, only show final response. log-level=quiet",
            "value": false
          },
          "info": {
            "type": "bool",
            "description": "Show progress",
            "value": false
          },
          "verbose": {
            "type": "bool",
            "description": "Show progress and debugging information",
            "value": false
          },
          "trace": {
            "type": "bool",
            "description": "Turn on tracing",
            "value": false
          },
          "model": {
            "shorthand": "m",
            "type": "string",
            "description": "LLM model alias defined in the model set",
            "value": ""
          }
        }
        ```
      Please follow the instructions carefully and accurately interpret the following user input.
    instruction:
      content: |
        As a sophisticated parsing agent, your mission is to accurately interpret mixed-mode user input,
        consisting of command-line arguments and free text. Follow this advanced guide to ensure
        comprehensive and conflict-free parsing, particularly focusing on the "agent" argument and
        conflict resolution:

        1. **Identify Flags and Options:**
          - Recognize command-line arguments using the `--flag` and `-f` notations.
          - Extract and record values for these arguments within the JSON structure.

        2. **Interpret Named Arguments from Free Text:**
          - Analyze free text for phrases suggesting specific arguments. For instance, map "I prefer model gpt4" to `--model`.
          - Utilize the default JSON descriptions to inform argument mappings.

        3. **Special Case Handling for "agent" Argument:**
          - Detect instances where input starts with `@<word>` or `<word>,` (ignoring leading spaces) and assign this as the value for `--agent` flag.
          - This special handling should be limited to the first occurrence in the input.

        4. **Conflict Resolution Strategy:**
          - When multiple instances of the same argument occur (either through flags or detected in the text), the most recently specified value should take precedence.
          - Example: If the user specifies `--model gpt3` and subsequently `-m gpt4`, the JSON should reflect `gpt4`.

        5. **Dynamic Argument Handling:**
          - Adaptively apply updates to the default JSON template based on input, updating as needed.
          - Support various argument sets through dynamic, description-informed processing.

        6. **Free Text Integration:**
          - Assign remaining free text to the `message` entry.
          - If `--message` is already given, append with a line feed (`"\n"`).

        7. **Generalize for Diverse Argument Configurations:**
          - Derive parsing strategies from JSON structure and descriptions, adjusting to different sets effectively.

        8. **Example of Conflict Resolution in Parsing:**

          Input JSON with description
          ```json
          {
            "agent": {
              "shorthand": "a",
              "type": "string",
              "description": "Specify the agent to use. shorthand: @<agent>",
              "value": ""
            },
            "instruction": {
              "type": "string",
              "description": "System role prompt",
              "value": ""
            },
            "message": {
              "type": "string",
              "description": "User query",
              "value": ""
            },
            "model": {
              "shorthand": "m",
              "type": "string",
              "description": "LLM model alias defined in the model set",
              "value": ""
            }
          }
          ```
          
          Input query:
          `@google --model gpt3 --instruction "you are a helpful agent" I want to use agent ddg --message "for search" --model gpt4 consider this for analysis`

          Into JSON:
          ```json
          {
            "agent": "ddg",
            "instruction": "you are a helpful agent",
            "message": "for search \n consider this for analysis",
            "model": "gpt4",
          }
          ```

        Your role is to meticulously apply these principles to parse inputs accurately into a structured JSON,
        resolving conflicts and prioritizing recent definitions to ensure consistency and precision in the output.

  - name: "input/parse"
    display: "Input Parser"
    description: |
      Processes input text, converting it to structured JSON format for downstream processing.
    flow:
      type: sequence
      actions:
        - "sh:parse"
    instruction:
      content:

  - name: "input/noop"
    display: "No-Op Parser"
    description: |
      Return the input text without any modifications.
    message: |
      {{.query}}
    instruction:
      content:
###